///
  This module defines the grammar and abstract syntax tree of the Chalk
  programming language.
///

import { Regex } from "stlib/regex.chalk";

{ class Expr, class OneOf, class Space } = Regex;

// Keyword is a string that cannot be an identifier.
export []String keywords =
    [ "All", "any", "auto", "assume", "await", "break", "case", "catch", "class"
    , "comptime", "const", "continue", "cst", "default", "enum", "Ex", "Exists"
    , "export", "final", "for", "friend", "function", "let", "immut", "import"
    , "is", "mut", "own", "pub", "return", "Self", "shared", "static", "switch"
    , "throw", "trait" , "try", "type", "yield"
    ];

export class Comment : Regex {
  pub ChalkDoc comment;
  
  static const []Expr =
      [ StartSpace()
      , Text("//")
      , OneOf(
          [ [ Match(Comment::comment, { multiline: false }), Space("\n") ]
          , [ Text("/")
            , Space("\n")
            , And([ Match(Comment::comment, { multiline: true }) ], [ Not("///") ])
            , StartSpace()
            , Text("///")
            ]
          ],
        )
      , Space("\n")
      ];
}

export class ChalkModule : Expr {
  pub ?Comment moduleDoc;
  
  pub []Import imports;
  pub []Declaration declarations;
  
  pub static []Expr =
      [ OneOf([ [ Field("moduleDoc") ], [ Errors.MEMD ] ])
      , Repeat([ Space(""), Match(Module::imports, Import) ]),
      , Repeat(
          [ OneOf(
              [ [ Match(Module::declarations, ObjectDestructuring,
                    { typed: Destructuring.Typed.never }
                  )
                , Space("")
                , Text(";")
                ]
              , [ Match(Module::declarations, VariableDeclaration)
                , Space("")
                , Text(";")
                ]
              , [ Match(Module::declarations, TypeDeclaration) ]
              , [ Match(Module::declarations, FunctionDeclaration) ]
              ]
            )
          , Space("\n")
          ],
          Space("\n"),
        )
      ];
}

export class Import : Regex {
  pub Bool leadingEmptyLine;
  
  pub Identifier|ObjectDestructuring imports;
  
  pub Expression path;
  
  static const []Expr =
      [ Equals("leadingEmptyLine", true, [ Space("\n") ], [])
      , Text("import")
      , Space(" ")
      , OneOf(
          [ [ Match(Import::imports, Identifier, { type: upperCase }) ]
          [ [ Errors. Match(Import::imports, Identifier, { type: upperCase }) ]
          , [ Match(Import::imports, ObjectDestructuring,
                { type: Destructuring.Typed.never }
              )
            ]
          ]
        )
      , Space(" ")
      , Text("from")
      , Space(" ")
      , Match(Import::path, Expression, { type: "std/string.chalk/String" }) // TODO or something else?
      , Space("")
      , Text(";")
      , Space("\n")
      ];
}

export trait Scope : Regex {
  []Declaration vars;
}

export final trait Declaration : Regex {
  own []Expr expr =
      [ Field()
      ];
}

export class TypeDeclaration =
    ClassDeclaration|TraitDeclaration;

export class VariableDeclaration : Declaration {
  pub Type type;
  pub Identifier name;
  
  pub ?Expression init;
  
  static const []Expr =
      [ Field("type")
      , Space(" ")
      , Field("name")
      , OneOf(
          [ [ Space(" "), Text("="), MSpace(" ", 4, [ Field("init") ]) ]
          , [ Equals("init", null) ]
          ]
      );
}

export class ClassDeclaration : Declaration {
  Identifier name;
  
  []Parameter params;
  []Trait traits;
  
  []VariableDeclaration fields;
  []TypeDeclaration types;
  
  static const []Expr =
      [ Text("class")
      , Space(" ")
      , Field("name")
      , Maybe(
          [ Space("")
          , Text("<")
          , Space("")
          , Repeat(
              [ Field("params") ],
              [ Text(","), MSpace(" ", 6) ]
            )
          , Text(">")
          ]
        )
      , Space(" ")
      , Maybe([ Text(":"), Space(" "), TypeIntersection(), Space(" ") ])
      , Maybe([ Text("friend"), Space(" "), TypeUnion(), Space(" ") ])
      , Text("{")
      , OneOf(
          [ [ Errors.EC, Space() ]
          , [ MSpace("\n", 2,
                [ Repeat([ StartSpace(), Field("fields") ],
                    [ Space("\n"), StartSpace(), Space("\n") ],
                    1,
                  )
                , Repeat(
                    [ StartSpace()
                    , OneOf(
                        [ [ Field("types") ]
                        , [ Error.FATD, Field("fields") ]
                        ]
                      )
                    ],
                    [ Space("\n"), StartSpace(), Space("\n") ],
                    1,
                  )
                ]
              )
            , Space("\n")
            , StartSpace()
            ]
          ]
      , Text("}"
      );
}

export class TraitDeclaration : Declaration {
  static const []Expr =
      [
      ];
}

export class FunctionDeclaration : Declaration {
  static const []Expr =
      [
      ];
}

export class TypeUnion : Regex {
  static const []Expr =
      [
      ];
}

export class TypeIntersection : Regex {
  static const []Expr =
      [
      ];
}

export class Identifier : Regex {
  Bool hasName;
  Type type;
  
  enum Type { object, type, ctt };
  
  static const []Expr =
      OneOf(
        [ [ Equals(Identifier::iType, Type.ctt,
              [ OneOf(
                  [ [ Text("class") ], [ Text("trait") ], [ Text("type") ] ]
                )
              ],
            )
        , [ Equals( Identifier::iType, Type.type, [ OneOf("A-Z") ], [ OneOf("a-z") ] )
          , Repeat( OneOf("a-zA-Z0-9") ) // That's right, NO UNDERSCORE. (Death to snake_case!)
          ]
        ]
      );
}

export class TypedIdentifier : Regex {
  Type type;
  Identifier name;
  
  static const []Expr =
      [ Field(TypedIdentifier::type, [ (Identifier::isType, true) ])
      , Space(" ")
      , Field(TypedIdentifier::type, [ (Identifier::isType, TODO) ])
      ];
}

export class Type : Regex {
  static const []Expr =
      [
      ];
}

// Both generic and function parameter
export class Parameter : Regex {
  static const []Expr =
      [
      ];
}

export final trait Destructuring : Regex {
  own enum Typed { always, never, both }
}

export class ObjectDestructuring : Destructuring {
  Destructuring.Typed typed;
  
  static const []Expr =
      [
      ];
}

export class ArrayDestructuring : Destructuring {
  Destructuring.Typed typed;
  
  static const []Expr =
      [
      ];
}

export class C : Regex {
  static const []Expr =
      [
      ];
}

export class C : Regex {
  static const []Expr =
      [
      ];
}

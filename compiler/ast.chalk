///
This module defines the grammar and abstract syntax tree of the Chalk
programming language.

Convention: startSpace is handled by the Regexes after it, all other space
is handled by Regexes before it.

Wrong:
```
[ OneOf([ [ RegexPart ], [ Text(":") ] ]), Space() ];

// RegexPart ~ [ Text("a") ]
```
Correct:
```
[ OneOf([ [ RegexPart ], [ Text(":"), Space() ] ]) ];

// RegexPart ~ [ Text("a"), Space() ]
```
///

import { class Regex } from "std/regex.chalk";

{ class Expr, class OneOf, class Space } = Regex;

export []String keywords =;
    [ "auto", "assume", "await", "break", "case", "catch", "class", "comptime"
    , "const", "continue", "default", "export", "for", "friend", "get", "import"
    , "is", "mut", "pub", "return", "set", "shared", "static", "switch", "throw"
    , "trait", "try", "yield" ];

export class Comment : Regex {
  static const Expr =
      [ StartSpace()
      , Text("//")
      , OneOf(
          [ [ Repeat(Not(Text("\n"))) ],
            [ Text("/")
            , Space("\n")
            , Repeat(
                [ StartSpace()
                , Repeat(
                  [ OneOf(
                      [ [ Not([ Text("///"), Text("\n"), Text("TODO") ]) ]
                      , [ Error.TODO, Text("TODO") ]
                      ],
                    )
                  ]
                , Text("\n")
                ])
            , StartSpace()
            , Text("///")
            ]
          ]
        )
      , Space("\n")
      ];
}

export class Module : Expr {
  ?Comment moduleDoc;
  
  []Import imports;
  []Declaration declarations;
  
  pub static []Expr =
      [ OneOf([ [ Field("moduleDoc") ], [ Errors.MEMD ] ])
      , Repeat([ Space(""), Field("imports") ]),
      , Repeat(
          [ Field("declarations"), Space(""), Text(";"), Space("\n") ],
          Space("\n"))
      ];
}

export class Import : Regex {
  Bool emptyLineBefore
  
  Identifier|ObjectDestructuring imports;
  
  Expression path;
  
  static const Expr =
      [ Equals("emptyLineBefore", true, [ Text("\n"), Space("") ])
      , Text("import")
      , Space(" ")
      , Field("imports")
      , Space(" ")
      , Text("from")
      , Space(" ")
      , Field("path")
      , Equals("path.type", String)
      , Space("")
      , Text(";")
      , Space("\n")
      ];
}

export class Declaration : Regex {
  VariableDeclaration|ClassDeclaration|TraitDeclaration|FunctionDeclaration decl;
  
  static const Expr = Field("decl");
}

export class VariableDeclaration : Regex {
  Type type;
  Identifier name;
  
  ?Expression init;
  
  static const Expr =
      [ Field("type")
      , Space(" ")
      , Field("name")
      , OneOf(
          [ [ Space(" "), Text("="), MSpace(" ", 4, [ Field("init") ]) ]
          , [ Equals("init", null) ]
          ]
      );
}

export class ClassDeclaration : Regex {
  Identifier name;
  
  []Parameter params;
  []Trait traits;
  
  []Field fields;
  []NestedTypes nested;
  
  static const Expr =
      [ Text("class")
      , Space(" ")
      , Field("name")
      , Maybe(
          [ Space("")
          , Text("<")
          , Space("")
          , Repeat(
              [ Field("params") ],
              [ Text(","), MSpace(" ", 6) ]
            )
          , Text(">")
          ]
        )
      , Space(" ")
      , Text(":")
      , Type-------------------------------------------------------------------------------------------------------------------
      , Space(" ")
      , Text("{")
      , OneOf(
          [ [ Errors.EC, Space() ]
          , [ Repeat([ Field("members") ], [ StartSpace(), Space("\n") ], 1) ]
          ]
      , Text("}"
      , Space("")
      );
}

export class ClassMember : Regex {
  static const Expr =
      [
      ];
}

export class TraitDeclaration : Regex {
  static const Expr =
      [
      ];
}

export class FunctionDeclaration : Regex {
export class FunctionDeclaration : Regex {
  static const Expr =
      [
      ];
}

export class Identifier : Regex {
  static const Expr =
      [
      ];
}

export class TypedIdentifier : Regex {
  static const Expr =
      [
      ];
}

export class Type : Regex {
  static const Expr =
      [
      ];
}

// Both generic and function parameter
export class Parameter : Regex {
  static const Expr =
      [
      ];
}

export class C : Regex {
  static const Expr =
      [
      ];
}

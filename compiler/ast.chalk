/**
 * Defines the grammar and abstract syntax tree of the Chalk programming language.
**/

import { Regex } from "std/regex.chalk";

class { Expr, OneOf, Space } = Regex;

class Module : Regex {
  ?ModuleDoc doc;
  
  [](Comment|Import|Declaration) contents;
  
  static const Expr =
      <Seq>
        <Field name="doc" />
        <Equals field="doc" value=null>
          <Seq>
            <Warning category="documentation" text="Missing module documentation." />
            <Space />
          </Seq>
        </Equals>
        <Repeat>
          <Seq>
            <OneOf>
              <Field name="contents">
              /* Note: support this:
               * <Field name="contents" node=(Import|Declaration)> // Does not match comments
               */
            </OneOf>
            <Space s="" />
            <Text str=";" />
            <Space s="\n" />
          </Seq>
          <Space s="\n" />
        </Repeat>
      </Seq>;
}

class Import : Regex {
  Identifier|ObjectDestructuring imports;
  
  Expression modulePath;
  
  static const Expr =
      Expr().string("import")
      .oneOf(
        Expr(space(" ", true))
          .field(imports, ObjectDestructuring)
          .expr(space(" ", true)),

        Expr(space(" ", false))
          .field("imports", Identifier)
          .expr(space(" ", false)),
      )
      .string("from")
      .expr(space(" ", false))
      .field("modulePath")
      .equals("modulePath.type", String);
}

class ModuleDoc : Regex {
  []String text;
  
  static const Expr =
      Expr().oneOf(
        Expr().warning("Style", Expr().string("/").repeat(Expr().string("*"), 2, 4).string("/")),
        Expr().warning(
          "Style",
          Expr().string("/*").ahead(Expr().noneOf("*")),
          Expr().string("/**"),
        )
          .warning(
            "Style",
            Expr().repeat(Expr().noneOf(
              Expr().string("\n"),
              Expr().string("*").ahead(Expr().string("/"))
            ), 1),
          )
          .maybe(Expr().string("\n"))
          .repeat(
            Expr().warning("Style", Expr().string(" * "), Expr())
            .repeat(Expr.field("text", Expr().noneOf("\n"))).string(\n),
          )
          .warning("Style", Expr().space().string("*/"), space("", true).string("**/"))
          .string("\n");
      );
}

class Declaration : Regex {
  VariableDeclaration|ClassDeclaration|TraitDeclaration|EnumDeclaration decl;
  
  static const Expr =
  Expr().oneOf(
    Expr().field("decl", VariableDeclaration),
    Expr().field("decl", ClassDeclaration),
    Expr().field("decl", TraitDeclaration),
    Expr().field("decl", EnumDeclaration),
  );
}

class VariableDeclaration : Regex {
  Identifier type;
  Identifier name;
  
  ?Expression init;
  
  static const Expr =
  startSpace
  .field("type", Identifier)
  .space(" ", false)
  .field("name", Identifier)
  .oneOf(
    space(" ", true).string("=").space(" ", true).field("init"),
    Expr.equals("init", null),
  );
}

class ClassDeclaration : Regex {
  Identifier name;
  
  [](VariableDeclaration|ClassDeclaration|TraitDeclaration|EnumDeclaration) members;
  
  static const Expr =
  Expr().string("class")
  .space(" ", false)
  .field("name")
  .space(" ", true)
  .string("{"
  .oneOf(
    Expr().warning("Empty class.", Expr.space()),
    Expr().repeat();
  )
  .string("}"
  );
}

class ClassBody : Regex {
  static const Expr =
  Expr;
}

class TraitDeclaration : Regex {
  static const Expr =
  Expr;
}

class EnumDeclaration : Regex {
  static const Expr =
  Expr;
}

class Comment : Regex {
  static const Expr =
  Expr;
}

class Identifier : Regex {
  static const Expr =
  Expr;
}

class TypedIdentifier : Regex {
  static const Expr =
  Expr;
}

class C : Regex {
  static const Expr =
  Expr;
}


// end

    Expr(space(" ", true))
    .oneOf(
      Expr().string("{")
      .expr(spaceIfMultiline(" "))
      .repeat(Identifier, space("").string(",").spaceIfMultiline(" ")),
    
      Expr().string("{").space().string("}")
      .equals("modulePath", StringLiteral("std/default.chalk")),
      
      Expr().warning("Empty import.", Expr().string("{").space().string("}")),
    ).expr(space(" ", true)),
    
    Expr(space(" ", false)).field("imports", Identifier).expr(space(" ", false)),
  )
  .;
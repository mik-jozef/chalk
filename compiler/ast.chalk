///
This module defines the grammar and abstract syntax tree of the Chalk
programming language.

Hint for Notepadqq:
  Indent is two spaces.

(Loose) convention?: startSpace is handled by the Regexes after it, all other
space is handled by Regexes before it.

Wrong:
```
[ OneOf([ [ RegexPart ], [ Text(":") ] ]), Space() ];

// RegexPart ~ [ Text("a") ]
```
Correct:
```
[ OneOf([ [ RegexPart ], [ Text(":"), Space() ] ]) ];

// RegexPart ~ [ Text("a"), Space() ]
```
///

import { class Regex } from "std/regex.chalk";

{ class Expr, class OneOf, class Space } = Regex;

///
Keyword is a string that cannot be an identifier.

Notably, `class` and `trait` are not keywords, but (the only) language-defined
types.
///
export []String keywords =
    [ "auto", "assume", "await", "break", "case", "catch", "comptime", "const"
    , "continue", "default", "enum", "export", "final", "for", "friend", "get"
    , "import", "is", "mut", "pub", "return", "set", "shared", "static", "switch"
    , "throw", "try", "type", "yield"
    ];

export class Comment : Regex {
  static const Expr =
      [ StartSpace()
      , Text("//")
      , OneOf(
          [ [ Repeat(Not(Text("\n"))) ],
            [ Text("/")
            , Space("\n")
            , Repeat(
                [ StartSpace()
                , Repeat(
                    [ OneOf(
                        [ [ Not([ Text("///"), Text("\n"), Text("TODO") ]) ]
                        , [ Error.TODO, Text("TODO") ]
                        ],
                      )
                    ]
                  )
                , Text("\n")
                ]
              )
            , StartSpace()
            , Text("///")
            ]
          ]
        )
      , Space("\n")
      ];
}

export class Module : Expr {
  ?Comment moduleDoc;
  
  []Import imports;
  []Declaration declarations;
  
  pub static []Expr =
      [ OneOf([ [ Field("moduleDoc") ], [ Errors.MEMD ] ])
      , Repeat([ Space(""), Field("imports") ]),
      , Repeat(
          [ Field("declarations"), Space(""), Text(";"), Space("\n") ],
          Space("\n"))
      ];
}

export class Import : Regex {
  Bool leadingEmptyLine;
  
  Identifier|ObjectDestructuring imports;
  
  Expression path;
  
  static const Expr =
      [ Equals("leadingEmptyLine", true, [ Space("\n") ])
      , Text("import")
      , Space(" ")
      , Field("imports")
      , Space(" ")
      , Text("from")
      , Space(" ")
      , Field("path")
      , Equals("path.type", String)
      , Space("")
      , Text(";")
      , Space("\n")
      ];
}

export class Declaration : Regex {
  VariableDeclaration|TypeDeclaration decl;
  
  static const Expr = Field("decl");
}

export class TypeDeclaration =
    ClassDeclaration|TraitDeclaration|CompositeTypeDeclaration; // WROOONG: Composite types cannot be declared

export class CompositeTypeDeclaration =
    FunctionDeclaration|TypeUnion|TypeIntersection;

export class VariableDeclaration : Regex {
  Type type;
  Identifier name;
  
  ?Expression init;
  
  static const Expr =
      [ Field("type")
      , Space(" ")
      , Field("name")
      , OneOf(
          [ [ Space(" "), Text("="), MSpace(" ", 4, [ Field("init") ]) ]
          , [ Equals("init", null) ]
          ]
      );
}

export class ClassDeclaration : Regex {
  Identifier name;
  
  []Parameter params;
  []Trait traits;
  
  []VariableDeclaration fields;
  []TypeDeclaration types;
  
  static const Expr =
      [ Text("class")
      , Space(" ")
      , Field("name")
      , Maybe(
          [ Space("")
          , Text("<")
          , Space("")
          , Repeat(
              [ Field("params") ],
              [ Text(","), MSpace(" ", 6) ]
            )
          , Text(">")
          ]
        )
      , Space(" ")
      , Maybe([ Text(":"), Space(" "), TypeIntersection(), Space(" ") ])
      , Maybe([ Text("friend"), Space(" "), TypeUnion(), Space(" ") ])
      , Text("{")
      , OneOf(
          [ [ Errors.EC, Space() ]
          , [ MSpace("\n", 2,
                [ Repeat([ StartSpace(), Field("fields") ],
                    [ Space("\n"), StartSpace(), Space("\n") ],
                    1,
                  )
                , Repeat(
                    [ StartSpace()
                    , OneOf(
                        [ [ Field("types") ]
                        , [ Error.FATD, Field("fields") ]
                        ]
                      )
                    ],
                    [ Space("\n"), StartSpace(), Space("\n") ],
                    1,
                  )
                ]
              )
            , Space("\n")
            , StartSpace()
            ]
          ]
      , Text("}"
      );
}

export class TraitDeclaration : Regex {
  static const Expr =
      [
      ];
}

export class FunctionDeclaration : Regex {
  static const Expr =
      [
      ];
}

export class TypeUnionDeclaration : Regex {
  static const Expr =
      [
      ];
}

export class TypeIntersectionDeclaration : Regex {
  static const Expr =
      [
      ];
}

export class Identifier : Regex {
  static const Expr =
      [
      ];
}

export class TypedIdentifier : Regex {
  static const Expr =
      [
      ];
}

export class Type : Regex {
  static const Expr =
      [
      ];
}

// Both generic and function parameter
export class Parameter : Regex {
  static const Expr =
      [
      ];
}

export class C : Regex {
  static const Expr =
      [
      ];
}

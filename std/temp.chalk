export class Defer {
  []*Function<void, []> functions();
  
  void add(*Function<void, []> fn) {
    functions.push(fn);
  }
  
  ~Defer() {
    
  }
}

trait Number {
  Self from(Int64 i);
  
  Self add(*Self number);
  Self sub(*Self number);
  Self mul(*Self number);
  Self div(*Self number);
  Self mod(*Self number);
  Self pow(*Self number);
  
  own Self add(Self a, *Self b) {
    return a.add(b);
  }
  
  own Self sub(Self a, *Self b) {
    return a.sub(b);
  }
  
  own Self mul(Self a, *Self b) {
    return a.mul(b);
  }
  
  own Self div(Self a, *Self b) {
    return a.div(b);
  }
  
  own Self mod(Self a, *Self b) {
    return a.mod(b);
  }
  
  own Self pow(Self a, *Self b) {
    return a.pow(b);
  }
  
  from(String);
  toString();
}

class Float32 : Nullable, Number {
  static Float32 null;
  static Float32 Infinity;
}

class Float64 : Number {
  static Float32 null;
  static Float32 Infinity;
}

export class Int64 : Number {
  
}

export class Int32 : Number {
  
}

export class Int16 : Number {
  
}

export class Int8 : Number {
  
}

export class Int = Int64;

class Compiler {
  run(File file) {}
  run(String s) {}
  translate(File file, Eval.format.cpp, Function<void, [ VirtualFile ]> fn) {}
  translate(String source, Eval.format.elf) {}
  translate(String source, Eval.format.function) {}
}

class Buffer {
  
}

class Class {}

trait Enum {
  String name;
  
  static values();
}

trait Collection<T> : Iterable<T> {
  get Int size;
  
  Self<T> from(*Collection<T> source);
  Self<T> from(*Iterable<Collection<T>> source);
  
  Bool hasValue(*const T t);
  
  Stream<*T> find(*const T t);
  *T first(*const T t) { return find(t).getValue(); }
}

class Functions {
  get<Ret, Object...>()
}

trait Comparator {}

class Math {}

trait ArrayTrait<T> {
  Bool unshift(Int index = 0);
  indexOf
}

class ArrayCell<T, Int i> {
  T t;
  
  ArrayCell<T, i - 1> nextCell;
  
  ?*T getValue(Int i) { return i == 0 ? t : nextCell.getValue(i - 1); }
}

class ArrayCell<T, 0> {
  ?*T getValue(Int i) { return null; }
}

class Array<T, Int i> : ArrayTrait<T> {
  ArrayCell<i> cell;
  
  new(void initializer(*T elem, Int index)) {}
  
  void sort(todo);
}

*T move<T>(T t) { return t; }
export class Union<> {
  pub Bool hasValue<X>() {}
  pub ~*X getValue<X>() {}
  pub ~*~X getValue<X>() ~ {}
}

class Array<T> : Indexable<T>, Iterable<T> {
  new(Int reserved = 0) {}
  new(Int length, void initializer(*T elem, Int index)) {}
  new(Stream<T> source) {}
  
  Bool shrink() {}
  
  Iterator<T> reverseIter() {}
  Array<T> reverse() {}
}

class Date {}
class RegeT {}

trait Map {}
class HashMap {}
class TreeMap {}

trait Set<T> : Iterable<T> {
  Bool has(*Set<T> a);
  
  *Set add(*T a);
  *Set remove(*T a);
  
  *Set<T> add(*Set<T> a) {
    a.forEach(e => add(e));
  }
  
  *Set<T> remove(*Set<T> a) {
    a.forEach(e => remove(e));
  }
  
  own Set union(Set a, *Set b) {
    return a.remove(e=>!b.has(e));
  }
  
  own Set intersection(Set a, *Set b) {
    return a.add(b);
  }
  
  own Set symmetricDifference(Set a, Set b) {
    return Set.difference(Set.union(a, b), Set.intersection(a, b));
  }
  
  own Set difference(Set a, *Set b) {
    return a.remove(b);
  }
}
class HashSet {}
class TreeSet {}

class Tuple {}

trait Pointer {
  own Int addressOf(*Object o) {}
  own *T pointerTo<T>(Int address) {}
}

class Reflect {
  class CreateType([]trait implementedTraits, []Field fields) comptime {} // Array of traits, oh fuck
  
  // Should Field rather be Field<T>? should nonstatic inner classes be just type variables instead of Java-like inner classes?
  Field createField(Field.Modifiers modifiers, const String name, class Type, Type value) {}
}

class Field friend Reflect {}

class Ptr : Pointer {}
class UniquePtr : Pointer {}
class SharedPtr : Pointer {}
class WeakPtr : Pointer {}

class Json {}

class Buffer {}

class Function<class R, []class params> {
  SharedPtr<Buffer> code;
  ?SharedPtr<StackFrame<?>> closure; // ???
  *StackFrame<code>; // ???
}

trait ModuleT {}
class Module {}

trait Stream<T> {
  T next();
  
  Bool all(Bool fn(*T elem));
  Bool any(Bool fn(*T elem));
  void forEach(void fn(*T elem));
  Self map<Val>(T fn(*T elem), Self newObject);
  Self filter(Bool fn(*Self elem));
  T reduce<T>(T fn(*T elem, *T acc), *T start);
  
  own Stream<Tuple<A, B>> zip(*Stream<A> a, *Stream<B> b);
  own Stream<T> zipWith<T>(*Stream<A> a, *Stream<B> b, T(*A a, *B b));
  static Self<Tuple<A, B>> zip(*Self<A> a, *Self<B> b);
  static Self<T> zipWith<T>(*Self<A> a, *Self<B> b, T(*A a, *B b));
  
  own Stream<T> flatten(Iterable<Stream<T>);
  
  Stream<T> find(Bool predicate(*const T)) {
    for T n = next() { predicate(n) && yield n; }
  }
  
  T first(Bool predicate(*const T)) {
    return find(predicate).next();
  }
}

trait AsyncStream<T> {
  *Self forEach(Promise fn(*T elem));
  Bool all(Promise<Bool> fn(*T elem));
  Bool any(Promise<Bool> fn(*T elem));
  []Out map<Val>(Promise<T> fn(*T elem), Self newObject);
  []T filter(Promise<Bool> fn(*Self elem));
  Out reduce<Out>(Promise<Out> fn(*T elem, *Out acc), *Out start);
}

class InStream : Iterator<Buffer> {
  Promise<Buffer> read(Int bytes) {}
}

class OutStream {
  Promise write(*Buffer b) {}
}

class IOStream : Iterable {
  InStream in() {}
  OutStream out() {}
}

trait Hashable {
  Int hash();
}

trait Iterable<T> : AsyncIterable<AsyncIterator<T>>, Stream<T> {
  class Iter;
  
  Iter iter();
  AsyncIterator<T> asyncIter() {
    for i : iter() { yield i };
  }
}

trait AsyncIterable<I: AsyncIterator> {
  I asyncIter();
}

class BigInt : Number {}
class StringBuilder {}
class Clipboard {
  get ?Clipboard systemClipboard;
}

class ChalkDoc {}

trait Iterator<T> : Iterable<T>, Stream<T> {
  ?*T find(*T elem);
  *T next();
  *T prev();
  Bool hasValue();
  *T getValue();
  []T take(Int n);
  []T takeAll();
  
  *Iterator iter() { return this; }
}

Promise<Module> import(*String path);

Iterator range(Int to) {
  return range(0, to, sgn(to));
}

Iterator range(Int from, Int to, Int step = to - from > 0 ? 1 : -1) {}

Iterator range(Float to, Float step = to > 0 ? 1 : -1) {
  return range(0, to, step);
}

Iterator range(Float from, Float to, Float step = to - from > 0 ? 1 : -1) {}

class EventEmitter<[]String events> {}

class LinkedList<T> {
  class Node<T> {
    ~T value;
    
    ~?*~Node<T> prev;
    ~?*~Node<T> neTt;
    
    new(*~T val) : value(val) {}
  }
  
  ~?Node<T> first;
  ~?*Node<T> last;
  ~*Node<T> current;
  
  pushBack();
  pushFront();
  popBack();
  popFront();
}

trait Slicable {
  Self slice(Int from, Int to);
}

trait Viewable : Slicable {
  Self view(Int from, Int to);
}

class CompleTFloat : Number {
  pub Float re;
  pub Float im;
  
  
}

trait Random {}

class SimpleRandom : Random {}

trait SQLDriver {}

// TODO zip, (a)png, json, something-like-markdown

class

trait FileTrait {}
class VirtualFile {}
class File {}

trait FolderTrait {}
class Folder {}
class VirtualFolder {}

class Log {}

trait Comparable {
  static class Comparator;
  
  static *Self clamp(*Self min, *Self value, *Self max) {
    min > max && throw(Error.new( // Or just `Error(`?
        "Minimum value must be less than the maximum value."));
    
    return switch {
      case value < min: min;
      case value > max: max;
      case _: value;
    }
  }
  
  static min(Iterable<Self> a);
  static max(Iterable<Self> a);
}
























